#!/usr/bin/env node

var app = require('../app');

var mongo = require('./mongo');

var fs = require('fs');
var debug = require('debug')('express-node-mongo-skeleton:server');
var http = require('http');
var proc;
var https = require('https');
var config = require('./config');
var moment = require("moment");

var arch = process.arch;
console.log('Arch:' + arch);

var arm = process.arch === 'arm';

/**
 * Get port from environment and store in Express.
 */
var port = normalizePort(process.env.PORT || '4443');

app.set('port', port);
app.set('domain', '0.0.0.0');
//https key/cert
var options;
if(arm){
	options = {
	  key: fs.readFileSync('/home/pi/hydra/file.pem'),
	  cert: fs.readFileSync('/home/pi/hydra/file.crt')
	};
}else{
	options = {
			  key: fs.readFileSync('./file.pem'),
			  cert: fs.readFileSync('./file.crt')
			};
}

/**
 * Create HTTP server.
 */
var serverHttps = https.createServer(options,app).listen(port);

/**
 * Listen on provided port, on all network interfaces.
 */

serverHttps.on('error', onError);
serverHttps.on('listening', onListening);

var io = require('socket.io').listen(serverHttps);

/**
 * Event listener for HTTP server "error" event.
 */
function onError(error) {
	if (error.syscall !== 'listen') {
		throw error;
	}

	var bind = typeof port === 'string' ? 'Pipe ' + port : 'Port ' + port

	// handle specific listen errors with friendly messages
	switch (error.code) {
	case 'EACCES':
		console.error(bind + ' requires elevated privileges');
		process.exit(1);
		break;
	case 'EADDRINUSE':
		console.error(bind + ' is already in use');
		process.exit(1);
		break;
	default:
		throw error;
	}
}

/**
 * Event listener for HTTP server "listening" event.
 */
function onListening() {
	var addr = serverHttps.address();
	var bind = typeof addr === 'string' ? 'pipe ' + addr : 'port ' + addr.port;
	debug('Listening on ' + bind);
}


var cron = require('node-schedule');
var spawn = require('child_process').spawn;

//use all_d to hold config.limit number of data sets for initial connections
var limit=config.limit, interval=config.interval, all_d=[];

var meteoHistory = [];

var lightsStatus = false;
var fansStatus = false;

var waterSensor = 0;
var now = new Date();
var BH1750;
var light;

if(arm){
	// initialize light sensor
	BH1750 = require('./bh1750');
	if(!light)
		light = new BH1750();
	
	var sensorLib = require('node-dht-sensor');
	console.log('initializing DHT:' + config.dhtVersion + ' sensor on pin:'	+ config.dhtPin);

	var sensor = {
		initialize : function() {
			return sensorLib.initialize(config.dhtVersion, config.dhtPin);
		},
		read : function() {
			var readout = sensorLib.read();
			var temperatureData = readout.temperature.toFixed(2);
			var humidityData = readout.humidity.toFixed(2);
			//console.log(moment().format() + ' TEMP: ' +temperatureData + ' HUMD: ' +humidityData);
			
			var meteoData = {
				temperature : temperatureData,
				humidity : humidityData
			};

			mongo.create('meteo',meteoData,function(err,response){
				if(err) console.log(err);
				//console.log('meteoData response ' + response);
				io.sockets.emit('meteoData', response); 
				
			});
			
			if(heatservice)
				heatservice.monitor(temperatureData,humidityData);

			setTimeout(function() {
				sensor.read();
			}, config.dhtTimeout);// 10min
		}
	};

	if (sensor.initialize()) {
		sensor.read();
	} else {
		console.warn('Failed to initialize sensor');
	}
}

var sockets = {};

io.sockets.on('connection', function(socket) {
	
	sockets[socket.id] = socket;
	console.log("Total clients connected : ", Object.keys(sockets).length);

	socket.emit('initialization', {interval:interval, limit:limit});
	
	mongo.findAll('meteo',function(err,response){
		if(err) console.log(err);
		//socket.emit('meteoHistory', response);
		console.log('findAll meteo:' + response.length);
		meteoHistory = response;
	});

	if(meteoHistory.length > 0 ){
		console.log('emit meteoHistory found :' + meteoHistory.length);
		socket.emit('meteoData', meteoHistory);
	}
	
	socket.on('reqint', function(d) {
		console.log('reqint invoked ' +d);
		if(!isNaN(d)) {
			interval=d;
			console.log('setting update interval to %d.', d);
		}
		socket.broadcast.emit('setint', d);
	});
	
	socket.on('onHistory', function(d) {
		console.log('onHistory value ' +d);
		
		mongo.findAll('meteo',function(err,response){
			if(err) console.log(err);
			//socket.emit('meteoHistory', response);
			console.log('findAll meteo:' + response.length);
			meteoHistory = response;
			socket.broadcast.emit('meteoHistory', response);
		});

		
//		if(!isNaN(d)) {
//			interval=d;
//			console.log('setting update interval to %d.', d);
//		}
//		socket.broadcast.emit('setint', d);
	});
	
//	socket.on('disconnect', function(){
//		console.log('disconnected');
//	});
	
	socket.on('disconnect', function() {
	    delete sockets[socket.id];

	    // no more sockets, kill the stream
	    if (Object.keys(sockets).length == 0) {
	      app.set('watchingFile', false);
	      if (proc) proc.kill();
	      fs.unwatchFile('./stream/image_stream.jpg');
	    }
	  });
	
	socket.on('lights', function(d){
		console.log('ui onLights ' + d);

		if(arm){
			var gpio = require("pi-gpio");
			if(d.status){
				lightservice.on();
			}else{
				lightservice.off();
			}
		}
	});
	
	socket.on('fans', function(d){
		console.log('ui onFans ' + d);
		if(arm){
			var gpio = require("pi-gpio");
			if(d.status){
				heatservice.on();
			}else{
				heatservice.off();
			}					
		}
	});
	
	socket.on('startStream', function() {
	    startStreaming(io);
	  });	
});


// +---------------- minute (0 - 59)
// |  +------------- hour (0 - 23)
// |  |  +---------- day of month (1 - 31)
// |  |  |  +------- month (1 - 12)
// |  |  |  |  +---- day of week (0 - 6) (Sunday=0 or 7)
// |  |  |  |  |
//t *  *  *  *  *  command to be executed
cron.scheduleJob('*/1 * * * *', function(){

	if(lightservice){
		lightservice.isOn(function(err,resp){
			if(err){ 
				console.log(err);
			}else{
				lightsStatus = resp;
				io.sockets.emit('initLights', {lights:lightsStatus});
			}
		});
	}
	
	if(heatservice){
		heatservice.isOn(function(err,resp){
			if(err){ 
				console.log(err);
			}else{
				fanStatus = resp;
				io.sockets.emit('initFans', {fans:fanStatus});
			}
		});
	}
	if(arm){
		
		// TODO use config.ds18x20 address 
		var value = tprobeSensor.probe('28-000005cff2dd');
		var waterData = {water: ''+value};
		mongo.create('water',waterData,function(err,response){
			if(err) console.log(err);
    		io.sockets.emit('waterData', response); 
		});
		
		value = tprobeSensor.probe('28-000005e66282');
		waterData = {water2: ''+value};
		mongo.create('water2',waterData,function(err,response){
			if(err) console.log(err);
		    //console.log('water2Data response ' + response);
    		io.sockets.emit('water2Data', response); 

		});
		
		light.readLight(function(value){
		    var lightData = {light:value};
		    mongo.create('light',lightData,function(err,response){
				if(err) console.log(err);
			    //console.log('lightData response ' + response);
			    io.sockets.emit('lightData', response); 
			});
		});
	}
	else
	{	
		var t = getRandom(19, 22).toFixed(2);
		var h = getRandom(65, 75).toFixed(2);
		mongo.create('meteo',{temperature:t,humidity:h},function(err,response){
			if(err) console.log(err);
		    //meteoHistory.push(response);
    		io.sockets.emit('meteoData', response); 
    		heatservice.monitor(t,h);
		});

		mongo.create('water',{water: getRandom(18, 25).toFixed(2)},function(err,response){
			if(err) console.log(err);
			io.sockets.emit('waterData', response); 
		});
		mongo.create('water2',{water2: getRandom(10, 15).toFixed(2)},function(err,response){
			if(err) console.log(err);
			io.sockets.emit('water2Data', response); 
		});
		mongo.create('light',{light: getRandom(18, 25).toFixed(2)},function(err,response){
			if(err) console.log(err);
			io.sockets.emit('lightData', response); 
		});
	}
});

process.on('SIGTERM', function() {
    console.log("\nShutdown..");
    if(arm)
	{
    	lightservice.stop();
    	heatservice.stop();
	}
    console.log("Exiting...");
    process.exit();
});


function getRandom(min, max) {
	return min + Math.floor(Math.random() * (max - min + 1));
}

/**
 * Normalize a port into a number, string, or false.
 */

function normalizePort(val) {
	var port = parseInt(val, 10);

	if (isNaN(port)) {
		// named pipe
		return val;
	}

	if (port >= 0) {
		// port number
		return port;
	}

	return false;
}

//WEBCAM STREAMING

function stopStreaming() {
	if (Object.keys(sockets).length == 0) {
		app.set('watchingFile', false);
		if (proc)
			proc.kill();
		fs.unwatchFile('./stream/image_stream.jpg');
	}
}

function startStreaming(io) {
  console.log('startStreaming CALLED');	
  if (app.get('watchingFile')) {
    io.sockets.emit('liveStream', 'image_stream.jpg?_t=' + (Math.random() * 100000));
    return;
  }
  if(arm)
  {
   var args = ["-w", "640", "-h", "480", "-o", "./stream/image_stream.jpg", "-t", "999999999", "-tl", "100"];
   proc = spawn('raspistill', args);
  }
  else
  {
	var args = ["-y","-f","video4linux2","-i", "/dev/video0","-vframes","1","./stream/image_stream.jpg"];
	proc = spawn('ffmpeg', args);
	console.log('startStreaming Spawned child pid: ' + proc.pid);
   
  }

  console.log('Watching for changes...');

  app.set('watchingFile', true);

  fs.watchFile('./stream/image_stream.jpg', function(current, previous) {
    io.sockets.emit('liveStream', 'image_stream.jpg?_t=' + (Math.random() * 100000));
  })
}


var lightservice = require('./lightservice');
lightservice.start();

var heatservice = require('./heatservice');
heatservice.start();

var tprobeSensor = require('./ds18x20');
